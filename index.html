<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Sci-Fi Air Writer</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Courier New', Courier, monospace; }
        
        /* å®¹å™¨å±‚çº§ç®¡ç† */
        #container { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
        
        /* 1. æ‘„åƒå¤´å±‚ (é•œåƒ + ç§‘å¹»è“æ»¤é•œ) */
        #input_video { 
            position: absolute; width: 100%; height: 100%; object-fit: cover; 
            transform: scaleX(-1); 
            filter: contrast(1.2) brightness(0.8) sepia(1) hue-rotate(180deg) saturate(1.5);
            opacity: 0.6;
            z-index: 0;
        }

        /* 2. ç»˜å›¾ä¸ç‰¹æ•ˆå±‚ */
        canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        #particle_layer { z-index: 11; }

        /* 3. UI ç•Œé¢å±‚ */
        #ui_panel {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 500px; height: 300px;
            background: rgba(0, 20, 40, 0.85);
            border: 2px solid #00ffff;
            box-shadow: 0 0 20px #00ffff;
            display: none; /* é»˜è®¤éšè— */
            flex-direction: column; justify-content: space-around; align-items: center;
            z-index: 20;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }
        
        /* UI å…ƒç´  */
        .row { display: flex; gap: 20px; width: 100%; justify-content: center; }
        .btn {
            width: 80px; height: 80px; border: 1px solid rgba(0,255,255,0.5);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #00ffff; cursor: pointer; transition: 0.2s;
            background: rgba(0,0,0,0.5);
        }
        .btn.active { background: #00ffff; color: #000; box-shadow: 0 0 15px #00ffff; }
        .btn:hover { border-color: #fff; }

        /* é¢œè‰²é€‰æ‹©å— */
        .color-block { width: 40px; height: 40px; border-radius: 50%; border: 2px solid #fff; }
        
        /* 4. è™šæ‹Ÿå…‰æ ‡ */
        #cursor {
            position: absolute; width: 20px; height: 20px;
            border: 2px solid #ff0055; border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 30;
            display: none;
            box-shadow: 0 0 10px #ff0055;
            transition: width 0.1s, height 0.1s;
        }
        #cursor::after { content: ''; position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #ff0055; transform: translate(-50%, -50%); }

        /* HUD è£…é¥° */
        #hud { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; box-shadow: inset 0 0 50px rgba(0,0,0,0.8); }
        .hud-text { position: absolute; bottom: 20px; left: 20px; color: #00ffff; opacity: 0.7; font-size: 14px; }
        
    </style>
</head>
<body>

<div id="container">
    <video id="input_video"></video>
    <div id="hud">
        <div class="hud-text">
            SYSTEM: ONLINE<br>
            HAND_TRACKING: ACTIVE<br>
            MODE: <span id="mode_display">STANDBY</span>
        </div>
    </div>
    
    <canvas id="draw_canvas"></canvas>
    <canvas id="particle_canvas"></canvas>

    <div id="cursor"></div>

    <div id="ui_panel">
        <h2 style="color:#00ffff; margin: 10px;">TOOL SELECTION</h2>
        <div class="row">
            <div class="btn" id="btn_pen" data-tool="pen">âœï¸<br>PEN</div>
            <div class="btn" id="btn_eraser" data-tool="eraser">ğŸ§¹<br>ERASER</div>
        </div>
        <div class="row">
            <div class="color-block" style="background: #ff0055;" data-color="#ff0055"></div>
            <div class="color-block" style="background: #00ffff;" data-color="#00ffff"></div>
            <div class="color-block" style="background: #ffff00;" data-color="#ffff00"></div>
            <div class="color-block" style="background: #ffffff;" data-color="#ffffff"></div>
        </div>
        <div class="row">
            <div class="btn" style="height: 40px; width: 60px;" data-size="2">S</div>
            <div class="btn" style="height: 40px; width: 60px;" data-size="6">M</div>
            <div class="btn" style="height: 40px; width: 60px;" data-size="12">L</div>
        </div>
    </div>
</div>

<script>
    // --- é…ç½®ä¸å˜é‡ ---
    const videoElement = document.getElementById('input_video');
    const drawCanvas = document.getElementById('draw_canvas');
    const particleCanvas = document.getElementById('particle_canvas');
    const ctx = drawCanvas.getContext('2d');
    const pCtx = particleCanvas.getContext('2d');
    const cursor = document.getElementById('cursor');
    const uiPanel = document.getElementById('ui_panel');
    const modeDisplay = document.getElementById('mode_display');
    const container = document.getElementById('container');

    let width, height;
    
    // çŠ¶æ€æœº
    const STATE = {
        tool: 'pen',
        color: '#00ffff',
        lineWidth: 6,
        isMenuOpen: false,
        lastPalmTime: 0, // é˜²æŠ–
        isDrawing: false,
        lastPoint: null,
        scale: 1,
        initialPinchDist: 0,
        isDissolving: false
    };

    // ç²’å­æ•°ç»„
    let particles = [];

    // åˆå§‹åŒ–å°ºå¯¸
    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        drawCanvas.width = width;
        drawCanvas.height = height;
        particleCanvas.width = width;
        particleCanvas.height = height;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
    }
    window.addEventListener('resize', resize);
    resize();

    // --- MediaPipe Hands è®¾ç½® ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});
    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
    });

    // --- æ ¸å¿ƒé€»è¾‘ ---

    function onResults(results) {
        // 1. å‡†å¤‡å·¥ä½œ
        pCtx.clearRect(0, 0, width, height); // æ¸…é™¤ç‰¹æ•ˆå±‚
        updateParticles(); // æ›´æ–°é›ªèŠ±

        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            cursor.style.display = 'none';
            return;
        }

        const landmarks = results.multiHandLandmarks; // æ‰€æœ‰æ‰‹çš„æ•°æ®
        
        // 2. åŒæ‰‹é€»è¾‘ (ç¼©æ”¾)
        if (landmarks.length === 2) {
            detectZoom(landmarks[0], landmarks[1]);
        } else {
            // é‡ç½®ç¼©æ”¾åˆå§‹çŠ¶æ€
            STATE.initialPinchDist = 0;
        }

        // 3. å•æ‰‹ä¸»é€»è¾‘ (ä¼˜å…ˆå¤„ç†ç¬¬ä¸€åªæ£€æµ‹åˆ°çš„æ‰‹)
        const hand = landmarks[0]; 
        
        // è½¬æ¢é£ŸæŒ‡åæ ‡ (8å·ç‚¹) åˆ°å±å¹•åƒç´ 
        // æ³¨æ„ï¼šè§†é¢‘æ˜¯é•œåƒçš„ (scaleX-1)ï¼Œä½†åæ ‡ä¹Ÿæ˜¯åçš„ï¼Œæ‰€ä»¥ x éœ€è¦ç”¨ 1 - x
        const indexTip = hand[8];
        const screenX = (1 - indexTip.x) * width; 
        const screenY = indexTip.y * height;

        // æ›´æ–°å…‰æ ‡ä½ç½®
        cursor.style.display = 'block';
        cursor.style.left = screenX + 'px';
        cursor.style.top = screenY + 'px';

        // --- æ‰‹åŠ¿è¯†åˆ« ---
        
        // A. æ£€æµ‹æ‰‹æŒå¼ å¼€ (5æŒ‡æŒ‡å°–éƒ½é«˜äºå…³èŠ‚) -> è§¦å‘/å…³é—­ UI
        if (detectOpenPalm(hand)) {
            const now = Date.now();
            if (now - STATE.lastPalmTime > 1000) { // 1ç§’å†·å´
                toggleMenu();
                STATE.lastPalmTime = now;
            }
        }

        // B. æ£€æµ‹ "V" å­—æ‰‹åŠ¿ (é£ŸæŒ‡+ä¸­æŒ‡ä¼¸ç›´ï¼Œå…¶ä»–å¼¯æ›²) -> è§¦å‘æ¶ˆæ•£
        if (detectVictory(hand) && !STATE.isDissolving) {
            startDissolveEffect();
        }

        // C. æ ¹æ® UI çŠ¶æ€åˆ†æµé€»è¾‘
        if (STATE.isMenuOpen) {
            // UI æ¨¡å¼ï¼šé£ŸæŒ‡ä½œä¸ºé¼ æ ‡ç‚¹å‡»
            handleUIInteraction(screenX, screenY, hand);
            modeDisplay.innerText = "MENU SELECTION";
        } else {
            // ç»˜å›¾æ¨¡å¼ï¼šæ£€æµ‹æåˆ (é£ŸæŒ‡+æ‹‡æŒ‡)
            const pinchDist = Math.hypot(hand[8].x - hand[4].x, hand[8].y - hand[4].y);
            const isPinching = pinchDist < 0.05; // é˜ˆå€¼

            if (isPinching) {
                cursor.style.backgroundColor = STATE.tool === 'eraser' ? '#fff' : STATE.color;
                cursor.style.width = '10px'; cursor.style.height = '10px';
                
                // ç»˜å›¾
                draw(screenX, screenY);
                modeDisplay.innerText = STATE.tool === 'eraser' ? "ERASING" : "WRITING";
            } else {
                cursor.style.backgroundColor = 'transparent';
                cursor.style.width = '20px'; cursor.style.height = '20px';
                STATE.isDrawing = false;
                STATE.lastPoint = null;
                modeDisplay.innerText = "HOVER";
            }
        }
    }

    // --- åŠŸèƒ½å‡½æ•° ---

    // 1. æ‰‹åŠ¿æ£€æµ‹å™¨
    function detectOpenPalm(lm) {
        // ç®€å•åˆ¤å®šï¼šæ‰€æœ‰æ‰‹æŒ‡æŒ‡å°–y < æŒ‡å…³èŠ‚y (å‡è®¾æ‰‹å‘ä¸Š)
        // ä¸¥æ ¼åˆ¤å®šï¼šæ‰‹æŒ‡ä¼¸ç›´ä¸”åˆ†æ•£ã€‚è¿™é‡Œç®€åŒ–ä¸ºæ‰‹æŒ‡ä¼¸ç›´ã€‚
        const tips = [8, 12, 16, 20];
        const pips = [6, 10, 14, 18];
        let extended = 0;
        if (Math.abs(lm[4].x - lm[2].x) > 0.05) extended++; // æ‹‡æŒ‡å¼ å¼€
        for (let i = 0; i < 4; i++) {
            if (lm[tips[i]].y < lm[pips[i]].y) extended++;
        }
        return extended === 5;
    }

    function detectVictory(lm) {
        // é£ŸæŒ‡(8) ä¸­æŒ‡(12) ä¼¸ç›´ï¼Œæ— å(16) å°æŒ‡(20) å¼¯æ›²
        const indexUp = lm[8].y < lm[6].y;
        const middleUp = lm[12].y < lm[10].y;
        const ringDown = lm[16].y > lm[14].y;
        const pinkyDown = lm[20].y > lm[18].y;
        // ç¡®ä¿ä¸¤æŒ‡åˆ†å¼€
        const dist = Math.hypot(lm[8].x - lm[12].x, lm[8].y - lm[12].y);
        return indexUp && middleUp && ringDown && pinkyDown && dist > 0.04;
    }

    // 2. ç¼©æ”¾é€»è¾‘
    function detectZoom(h1, h2) {
        // è®¡ç®—ä¸¤åªæ‰‹é£ŸæŒ‡çš„è·ç¦»
        const x1 = (1 - h1[8].x) * width; const y1 = h1[8].y * height;
        const x2 = (1 - h2[8].x) * width; const y2 = h2[8].y * height;
        const dist = Math.hypot(x2 - x1, y2 - y1);

        if (STATE.initialPinchDist === 0) {
            STATE.initialPinchDist = dist;
        } else {
            const delta = dist - STATE.initialPinchDist;
            // ç®€å•å¹³æ»‘å¤„ç†
            const newScale = Math.max(0.5, Math.min(3, STATE.scale + delta * 0.005));
            STATE.scale = newScale;
            // åº”ç”¨ç¼©æ”¾
            drawCanvas.style.transform = `scale(${STATE.scale})`;
            // é‡ç½®åŸºå‡†é˜²æ­¢é£é€Ÿç¼©æ”¾
            STATE.initialPinchDist = dist; 
            modeDisplay.innerText = `ZOOM: ${STATE.scale.toFixed(1)}x`;
        }
    }

    // 3. ç»˜å›¾é€»è¾‘
    function draw(x, y) {
        // åå‘ç¼©æ”¾åæ ‡ï¼Œç¡®ä¿åœ¨æ”¾å¤§æ—¶ç”»ç¬”ä½ç½®æ­£ç¡®
        // è¿™æ˜¯ä¸€ä¸ªç®€åŒ–çš„å¤„ç†ï¼Œæ›´ç²¾ç¡®çš„éœ€è¦è®¡ç®—å˜æ¢çŸ©é˜µ
        const rect = drawCanvas.getBoundingClientRect();
        const canvasX = (x - rect.left) / STATE.scale;
        const canvasY = (y - rect.top) / STATE.scale;

        if (!STATE.isDrawing) {
            STATE.isDrawing = true;
            STATE.lastPoint = { x: canvasX, y: canvasY };
            return;
        }

        ctx.beginPath();
        ctx.strokeStyle = STATE.tool === 'eraser' ? 'rgba(0,0,0,1)' : STATE.color;
        ctx.globalCompositeOperation = STATE.tool === 'eraser' ? 'destination-out' : 'source-over';
        ctx.lineWidth = STATE.lineWidth;
        
        ctx.moveTo(STATE.lastPoint.x, STATE.lastPoint.y);
        // äºŒæ¬¡è´å¡å°”æ›²çº¿è®©çº¿æ¡æ›´å¹³æ»‘
        const midX = (STATE.lastPoint.x + canvasX) / 2;
        const midY = (STATE.lastPoint.y + canvasY) / 2;
        ctx.quadraticCurveTo(STATE.lastPoint.x, STATE.lastPoint.y, midX, midY);
        ctx.lineTo(canvasX, canvasY);
        
        ctx.stroke();
        
        STATE.lastPoint = { x: canvasX, y: canvasY };
    }

    // 4. UI äº¤äº’é€»è¾‘
    function toggleMenu() {
        STATE.isMenuOpen = !STATE.isMenuOpen;
        uiPanel.style.display = STATE.isMenuOpen ? 'flex' : 'none';
        // èœå•å¼€å¯æ—¶é‡ç½®ç¼©æ”¾ï¼Œæ–¹ä¾¿æ“ä½œ
        if(STATE.isMenuOpen) {
            STATE.scale = 1;
            drawCanvas.style.transform = `scale(1)`;
        }
    }

    function handleUIInteraction(x, y, hand) {
        // æ£€æµ‹é£ŸæŒ‡æ˜¯å¦æ˜¯â€œç‚¹å‡»â€å§¿æ€ï¼šè¿™é‡Œç®€åŒ–ä¸ºåªè¦æ‚¬åœåœ¨æŒ‰é’®ä¸Šè¶…è¿‡ä¸€å®šæ—¶é—´æˆ–ç›´æ¥ç§»åŠ¨ä¸Šå»
        // æˆ‘ä»¬å¯ä»¥ç”¨ document.elementFromPoint
        
        // ä¸´æ—¶éšè—å…‰æ ‡ä»¥æ£€æµ‹ä¸‹æ–¹å…ƒç´ 
        cursor.style.display = 'none'; 
        const elem = document.elementFromPoint(x, y);
        cursor.style.display = 'block';

        if (elem) {
            // å¤„ç†å·¥å…·é€‰æ‹©
            if (elem.dataset.tool) {
                STATE.tool = elem.dataset.tool;
                updateUIStyles();
            }
            // å¤„ç†é¢œè‰²é€‰æ‹©
            if (elem.dataset.color) {
                STATE.color = elem.dataset.color;
                STATE.tool = 'pen'; // é€‰é¢œè‰²è‡ªåŠ¨åˆ‡å›ç¬”
                updateUIStyles();
            }
            // å¤„ç†å¤§å°
            if (elem.dataset.size) {
                STATE.lineWidth = parseInt(elem.dataset.size);
            }
        }
    }

    function updateUIStyles() {
        document.getElementById('btn_pen').className = STATE.tool === 'pen' ? 'btn active' : 'btn';
        document.getElementById('btn_eraser').className = STATE.tool === 'eraser' ? 'btn active' : 'btn';
    }

    // 5. é›ªèŠ±æ¶ˆæ•£ç‰¹æ•ˆ (æ ¸å¿ƒç®—æ³•)
    function startDissolveEffect() {
        STATE.isDissolving = true;
        modeDisplay.innerText = "DISSOLVING...";

        // 1. è·å–å½“å‰ç”»å¸ƒåƒç´ 
        const imgData = ctx.getImageData(0, 0, width, height);
        const data = imgData.data;

        // 2. æŠ½æ ·ç”Ÿæˆç²’å­ (æ¯éš”4åƒç´ æŠ½æ ·ï¼Œæå‡æ€§èƒ½)
        for (let y = 0; y < height; y += 5) {
            for (let x = 0; x < width; x += 5) {
                const index = (y * width + x) * 4;
                if (data[index + 3] > 0) { // å¦‚æœæœ‰é€æ˜åº¦(å³æœ‰ç¬”è¿¹)
                    particles.push({
                        x: x,
                        y: y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: Math.random() * 2 + 1, // å‘ä¸‹è½
                        color: `rgba(${data[index]},${data[index+1]},${data[index+2]},${data[index+3]/255})`,
                        life: 1.0
                    });
                }
            }
        }

        // 3. æ¸…ç©ºåŸç”»æ¿
        ctx.clearRect(0, 0, width, height);
        
        // 0.5ç§’åå…è®¸é‡æ–°ç”»
        setTimeout(() => { STATE.isDissolving = false; }, 500);
    }

    function updateParticles() {
        if (particles.length === 0) return;

        for (let i = particles.length - 1; i >= 0; i--) {
            const p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.01; // é€æ¸æ¶ˆå¤±

            // ç»˜åˆ¶
            pCtx.fillStyle = p.color;
            pCtx.globalAlpha = p.life; // ä½¿ç”¨å…¨å±€é€æ˜åº¦æ¨¡æ‹Ÿæ·¡å‡º
            pCtx.fillRect(p.x, p.y, 3, 3);
            pCtx.globalAlpha = 1.0;

            if (p.life <= 0 || p.y > height) {
                particles.splice(i, 1);
            }
        }
    }

    // --- å¯åŠ¨ ---
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });
    camera.start();

</script>
</body>
</html>
