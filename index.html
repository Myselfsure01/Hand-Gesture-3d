<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI éš”ç©ºæ‰‹åŠ¿ç»˜å›¾ç³»ç»Ÿ</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #222; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; width: 100vw; height: 100vh; transform: scaleX(-1); /* é•œåƒç¿»è½¬ */ }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; pointer-events: none; text-align: center;
        }
        /* é•œåƒç¿»è½¬UIå®¹å™¨ï¼Œé˜²æ­¢æ–‡å­—åå‘ */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½ AI æ¨¡å‹ä¸æ‘„åƒå¤´...<br><span style="font-size:14px; opacity:0.7">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>
    <video id="input_video" style="display:none"></video>
    <canvas id="output_canvas"></canvas>

<script>
/**
 * é…ç½®ä¸çŠ¶æ€ç®¡ç†
 */
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d');
const loading = document.getElementById('loading');

// å±å¹•å°ºå¯¸é€‚é…
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// ç³»ç»ŸçŠ¶æ€
const state = {
    isMenuOpen: false,
    mode: 'draw', // 'draw' or 'erase'
    color: '#00FF00', // é»˜è®¤ç»¿è‰²
    lineWidth: 5,
    lastPinchDist: 0, // ç”¨äºç¼©æ”¾
    canvasScale: 1,
    canvasOffset: { x: 0, y: 0 },
    menuCooldown: 0, // é˜²æ­¢èœå•é¢‘ç¹å¼€å…³
    prevTwoFingerDist: null // åŒæ‰‹ç¼©æ”¾è®°å½•
};

// ç¬”è¿¹å­˜å‚¨
let strokes = []; // Array of { points: [{x,y}], color, size }
let currentStroke = null;

// ç²’å­ç³»ç»Ÿ (é›ªèŠ±ç‰¹æ•ˆ)
let particles = [];

// UI æŒ‰é’®å®šä¹‰
const buttons = [
    { id: 'pen', label: 'âœï¸ ç¬”', x: 100, y: 100, w: 80, h: 80, color: '#444', action: () => { state.mode = 'draw'; } },
    { id: 'eraser', label: 'ğŸ§¼ æ“¦', x: 200, y: 100, w: 80, h: 80, color: '#444', action: () => { state.mode = 'erase'; } },
    { id: 'red', label: 'ğŸ”´', x: 100, y: 200, w: 80, h: 80, color: '#FF0000', action: () => { state.color = '#FF0000'; state.mode = 'draw'; } },
    { id: 'green', label: 'ğŸŸ¢', x: 200, y: 200, w: 80, h: 80, color: '#00FF00', action: () => { state.color = '#00FF00'; state.mode = 'draw'; } },
    { id: 'blue', label: 'ğŸ”µ', x: 100, y: 300, w: 80, h: 80, color: '#0000FF', action: () => { state.color = '#0000FF'; state.mode = 'draw'; } },
    { id: 'size+', label: 'â• ç²—', x: 100, y: 400, w: 80, h: 80, color: '#555', action: () => { state.lineWidth = Math.min(30, state.lineWidth + 2); } },
    { id: 'size-', label: 'â– ç»†', x: 200, y: 400, w: 80, h: 80, color: '#555', action: () => { state.lineWidth = Math.max(1, state.lineWidth - 2); } },
];

/**
 * æ ¸å¿ƒé€»è¾‘ï¼šæ‰‹åŠ¿è¯†åˆ«ä¸ç»˜åˆ¶
 */
function onResults(results) {
    loading.style.display = 'none';
    
    // 1. æ¸…ç©ºç”»å¸ƒå¹¶ç»˜åˆ¶èƒŒæ™¯è§†é¢‘
    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
    
    // 2. ç»˜åˆ¶å·²æœ‰çš„ç¬”è¿¹
    drawStrokes();

    // 3. å¤„ç†ç²’å­ç‰¹æ•ˆ (é›ªèŠ±)
    updateAndDrawParticles();

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        // ç®€å•å¤„ç†ï¼šå¦‚æœæœ‰ä¸¤åªæ‰‹
        const hands = results.multiHandLandmarks;
        const hand1 = hands[0];
        const hand2 = hands.length > 1 ? hands[1] : null;

        // --- æ‰‹åŠ¿æ£€æµ‹é€»è¾‘ ---
        
        // A. åŒæ‰‹ç¼©æ”¾æ£€æµ‹
        if (hand1 && hand2) {
            detectZoom(hand1, hand2);
        } else {
            state.prevTwoFingerDist = null; // é‡ç½®åŒæŒ‡çŠ¶æ€
        }

        // B. å•æ‰‹é€»è¾‘ (ä¼˜å…ˆå¤„ç†ç¬¬ä¸€åªæ‰‹)
        const lm = hand1;
        
        // å…³é”®ç‚¹åæ ‡è½¬æ¢
        const indexTip = { x: lm[8].x * canvas.width, y: lm[8].y * canvas.height };
        const thumbTip = { x: lm[4].x * canvas.width, y: lm[4].y * canvas.height };
        const middleTip = { x: lm[12].x * canvas.width, y: lm[12].y * canvas.height };
        const wrist = { x: lm[0].x * canvas.width, y: lm[0].y * canvas.height };

        // è®¡ç®—è·ç¦»
        const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
        const peaceDist = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);
        const wristToIndex = Math.hypot(indexTip.x - wrist.x, indexTip.y - wrist.y);
        const wristToMiddle = Math.hypot(middleTip.x - wrist.x, middleTip.y - wrist.y);
        const wristToPinky = Math.hypot(lm[20].x * canvas.width - wrist.x, lm[20].y * canvas.height - wrist.y);

        // çŠ¶æ€ 1: æ£€æµ‹â€œæ‰‹æŒæ‰“å¼€â€ -> åˆ‡æ¢èœå•
        // ç®€å•åˆ¤æ–­ï¼šæ‰€æœ‰æ‰‹æŒ‡éƒ½ä¼¸ç›´ä¸”åˆ†å¼€ (é£ŸæŒ‡ã€ä¸­æŒ‡ã€å°æŒ‡ç¦»æ‰‹è…•è¾ƒè¿œ)
        const isPalmOpen = wristToIndex > 150 && wristToMiddle > 150 && wristToPinky > 150 && pinchDist > 100;

        if (state.menuCooldown > 0) state.menuCooldown--;

        if (isPalmOpen && state.menuCooldown === 0) {
            state.isMenuOpen = !state.isMenuOpen; // åˆ‡æ¢èœå•çŠ¶æ€
            state.menuCooldown = 30; // å†·å´æ—¶é—´ï¼Œé˜²æ­¢é—ªçƒ
            // å¦‚æœæ‰“å¼€èœå•ï¼Œåœæ­¢å½“å‰ä¹¦å†™
            currentStroke = null; 
        }

        // çŠ¶æ€ 2: èœå•å¼€å¯æ—¶çš„äº¤äº’
        if (state.isMenuOpen) {
            drawMenu(indexTip); // ä¼ å…¥é£ŸæŒ‡å°–åæ ‡ç”¨äºæ£€æµ‹ç‚¹å‡»
            drawCursor(indexTip, 'pointer');
        } 
        // çŠ¶æ€ 3: èœå•å…³é—­æ—¶çš„äº¤äº’ (ä¹¦å†™/æ¸…é™¤)
        else {
            
            // 3.1 æ£€æµ‹â€œå‰ªåˆ€æ‰‹/Vå­—â€ -> è§¦å‘é›ªèŠ±æ¶ˆæ•£
            // ç®€å•é€»è¾‘ï¼šé£ŸæŒ‡ä¸­æŒ‡æ‰“å¼€ï¼Œä¸”ä¸æ˜¯å†™å­—çŠ¶æ€
            if (peaceDist > 60 && !currentStroke && wristToIndex > 100 && wristToMiddle > 100) {
                 // è§¦å‘æ¶ˆæ•£
                 if (strokes.length > 0) {
                     explodeStrokesToParticles();
                 }
                 drawCursor(indexTip, 'magic'); // é­”æ³•æ£’å…‰æ ‡
            }
            // 3.2 æ£€æµ‹â€œæåˆâ€ -> å†™å­—
            else if (pinchDist < 40) {
                // å¼€å§‹æˆ–ç»§ç»­ä¹¦å†™
                // åæ ‡éœ€è¦è€ƒè™‘åè½¬å¸¦æ¥çš„Xè½´å½±å“ (å› ä¸ºdrawImageä¹‹åæˆ‘ä»¬æ˜¯åœ¨é•œåƒåæ ‡ç³»)
                // ä½†MediaPipeåæ ‡æ˜¯å½’ä¸€åŒ–çš„ï¼Œæˆ‘ä»¬å·²ç»åœ¨ä¸Šé¢ä¹˜äº†å®½é«˜ã€‚
                // å…³é”®ï¼šä¸ºäº†è®©å­—è·Ÿç€æ‰‹èµ°ï¼Œæˆ‘ä»¬éœ€è¦åç®—ç¼©æ”¾åçš„åæ ‡
                const drawX = (indexTip.x - state.canvasOffset.x) / state.canvasScale;
                const drawY = (indexTip.y - state.canvasOffset.y) / state.canvasScale;

                if (!currentStroke) {
                    currentStroke = { 
                        points: [{x: drawX, y: drawY}], 
                        color: state.mode === 'erase' ? 'rgba(0,0,0,0)' : state.color, // æ©¡çš®æ“¦é€»è¾‘ç¨å¤æ‚ï¼Œè¿™é‡Œåšç®€å•å¤„ç†ï¼šæ©¡çš®æ“¦å…¶å®æ˜¯åˆ‡å‰²çº¿æ¡ï¼Œä¸ºç®€åŒ–ï¼Œæˆ‘ä»¬è¿™é‡Œå‡è®¾æ©¡çš®æ“¦æ˜¯â€œç™½è‰²â€è¦†ç›–æˆ–è€…é€»è¾‘æ“¦é™¤ï¼Œè¿™é‡Œç®€åŒ–ä¸ºé€æ˜è‰²å®é™…ä¸Šæ˜¯å ä½ï¼Œä¸‹é¢æ¸²æŸ“æ—¶å•ç‹¬å¤„ç†
                        isEraser: state.mode === 'erase',
                        size: state.lineWidth 
                    };
                    strokes.push(currentStroke);
                } else {
                    currentStroke.points.push({x: drawX, y: drawY});
                }
                
                // è§†è§‰åé¦ˆï¼šåœ¨æåˆå¤„ç”»ä¸€ä¸ªå°åœˆ
                ctx.beginPath();
                ctx.arc(indexTip.x, indexTip.y, 5, 0, 2 * Math.PI);
                ctx.fillStyle = state.color;
                ctx.fill();

            } else {
                // åœæ­¢ä¹¦å†™
                currentStroke = null;
                drawCursor(indexTip, 'hover');
            }
        }
        
        // ç»˜åˆ¶éª¨æ¶ï¼ˆå¯é€‰ï¼Œè¾…åŠ©è°ƒè¯•ï¼‰
        // drawConnectors(ctx, lm, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 1});
    }

    ctx.restore();
}

/**
 * è¾…åŠ©åŠŸèƒ½å‡½æ•°
 */

function drawCursor(pos, type) {
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 8, 0, 2 * Math.PI);
    if (type === 'pointer') ctx.fillStyle = 'yellow';
    else if (type === 'magic') ctx.fillStyle = 'cyan';
    else ctx.fillStyle = 'white';
    ctx.fill();
    ctx.strokeStyle = 'black';
    ctx.lineWidth = 1;
    ctx.stroke();
}

// ç»˜åˆ¶æ‰€æœ‰ç¬”è¿¹
function drawStrokes() {
    ctx.save();
    // åº”ç”¨å…¨å±€ç¼©æ”¾å’Œå¹³ç§»
    ctx.translate(state.canvasOffset.x, state.canvasOffset.y);
    ctx.scale(state.canvasScale, state.canvasScale);

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';

    for (let stroke of strokes) {
        if (stroke.points.length < 2) continue;
        
        ctx.beginPath();
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) {
            ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        }
        
        if (stroke.isEraser) {
            ctx.globalCompositeOperation = 'destination-out';
            ctx.lineWidth = stroke.size * 2;
        } else {
            ctx.globalCompositeOperation = 'source-over';
            ctx.strokeStyle = stroke.color;
            ctx.lineWidth = stroke.size;
        }
        ctx.stroke();
    }
    ctx.restore();
}

// ç»˜åˆ¶UIé¢æ¿
function drawMenu(pointerPos) {
    // åŠé€æ˜èƒŒæ™¯
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(50, 50, 250, 450);
    
    ctx.fillStyle = 'white';
    ctx.font = '20px Arial';
    ctx.fillText("å½“å‰: " + (state.mode === 'erase' ? "æ©¡çš®" : "ç¬”"), 70, 80);
    ctx.fillText("å¤§å°: " + state.lineWidth, 180, 80);

    for (let btn of buttons) {
        // ç»˜åˆ¶æŒ‰é’®
        ctx.fillStyle = btn.color;
        // é«˜äº®é€‰ä¸­
        if (state.mode === 'draw' && btn.color === state.color && btn.id.includes('red')) ctx.strokeStyle = 'white';
        
        // ç¢°æ’æ£€æµ‹
        let isHover = pointerPos.x > btn.x && pointerPos.x < btn.x + btn.w &&
                      pointerPos.y > btn.y && pointerPos.y < btn.y + btn.h;
        
        if (isHover) {
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 3;
            ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
            
            // ç®€å•çš„é˜²æŠ–ç‚¹å‡»é€»è¾‘ï¼šå¦‚æœæ‚¬åœè¶…è¿‡ä¸€å®šå¸§æ•°ç®—ç‚¹å‡»ï¼Œæˆ–è€…ç®€å•åœ°æ£€æµ‹è¿›å…¥ç¬é—´
            // è¿™é‡Œä¸ºäº†æµç•…ï¼Œé‡‡ç”¨â€œæ¥è§¦å³è§¦å‘â€ï¼Œä½†åŠ ä¸Šä¸€ç‚¹å†·å´
            // å®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨å€’è®¡æ—¶åœˆ
            btn.action();
        }

        ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
        ctx.fillStyle = 'white';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(btn.label, btn.x + btn.w/2, btn.y + btn.h/2);
    }
}

// åŒæ‰‹ç¼©æ”¾é€»è¾‘
function detectZoom(hand1, hand2) {
    const p1 = { x: hand1[8].x * canvas.width, y: hand1[8].y * canvas.height };
    const p2 = { x: hand2[8].x * canvas.width, y: hand2[8].y * canvas.height };
    
    // åªæœ‰å½“ä¸¤ä¸ªé£ŸæŒ‡éƒ½ç«–èµ·ï¼ˆä¸”å…¶ä»–æ‰‹æŒ‡å¼¯æ›²ï¼Œè¿™é‡Œç®€åŒ–ä¸ºåªæ£€æµ‹é£ŸæŒ‡ï¼‰æ—¶è§¦å‘
    // è¿™é‡Œç®€å•é€šè¿‡ä¸¤ç‚¹è·ç¦»å˜åŒ–æ¥åˆ¤æ–­
    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
    
    if (state.prevTwoFingerDist) {
        const delta = dist - state.prevTwoFingerDist;
        if (Math.abs(delta) > 2) { // é˜ˆå€¼
            const scaleFactor = 1 + delta * 0.002;
            state.canvasScale *= scaleFactor;
            // é™åˆ¶ç¼©æ”¾èŒƒå›´
            state.canvasScale = Math.max(0.5, Math.min(3.0, state.canvasScale));
            
            // å¯é€‰ï¼šä»¥ä¸­å¿ƒç‚¹ç¼©æ”¾ï¼ˆè¿™é‡Œç®€åŒ–ä¸ºåŸç‚¹ç¼©æ”¾ï¼‰
        }
    }
    state.prevTwoFingerDist = dist;
}

/**
 * ç²’å­ç³»ç»Ÿï¼šé›ªèŠ±æ¶ˆæ•£ç‰¹æ•ˆ
 */
function explodeStrokesToParticles() {
    // å°†æ‰€æœ‰ç¬”ç”»è½¬åŒ–ä¸ºç²’å­
    for (let stroke of strokes) {
        if (stroke.isEraser) continue;
        // é™ä½é‡‡æ ·ç‡ï¼Œä¸è¦æ¯ä¸ªç‚¹éƒ½ç”Ÿæˆï¼Œå¦åˆ™å¤ªå¡
        for (let i = 0; i < stroke.points.length; i += 2) {
            const pt = stroke.points[i];
            // è½¬æ¢ä¸ºå½“å‰å±å¹•åæ ‡
            const screenX = pt.x * state.canvasScale + state.canvasOffset.x;
            const screenY = pt.y * state.canvasScale + state.canvasOffset.y;
            
            particles.push({
                x: screenX,
                y: screenY,
                vx: (Math.random() - 0.5) * 4, // éšæœºæ°´å¹³æ¼‚ç§»
                vy: Math.random() * 2 + 1,     // å‘ä¸‹æ‰è½
                life: 1.0,                     // é€æ˜åº¦/ç”Ÿå‘½å€¼
                color: stroke.color,
                size: stroke.size
            });
        }
    }
    strokes = []; // æ¸…ç©ºç¬”è¿¹
}

function updateAndDrawParticles() {
    if (particles.length === 0) return;

    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.015; // æ…¢æ…¢æ¶ˆå¤±
        
        // åƒé›ªèŠ±ä¸€æ ·å·¦å³æ‘‡æ‘†
        p.vx += (Math.random() - 0.5) * 0.5;

        if (p.life <= 0) {
            particles.splice(i, 1);
        } else {
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size / 2, 0, Math.PI * 2);
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }
}

/**
 * åˆå§‹åŒ– MediaPipe
 */
const hands = new Hands({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
}});

hands.setOptions({
    maxNumHands: 2, // å¼€å¯åŒæ‰‹æ£€æµ‹
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
});

hands.onResults(onResults);

const camera = new Camera(document.getElementById('input_video'), {
    onFrame: async () => {
        await hands.send({image: document.getElementById('input_video')});
    },
    width: 1280,
    height: 720
});
camera.start();

</script>
</body>
</html>
