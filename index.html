<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI éš”ç©ºæ‰‹åŠ¿ç»˜å›¾ç³»ç»Ÿ Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; padding: 0; overflow: hidden; background-color: #111; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
        /* æ ¸å¿ƒï¼šCanvasä¾ç„¶ä¿æŒé•œåƒç¿»è½¬ï¼Œä»¥ä¿è¯ç»˜ç”»ä½“éªŒè‡ªç„¶ */
        canvas { display: block; width: 100vw; height: 100vh; transform: scaleX(-1); }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 24px; pointer-events: none; text-align: center;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
        }
    </style>
</head>
<body>

    <div id="loading">æ­£åœ¨åŠ è½½ AI æ¨¡å‹ä¸æ‘„åƒå¤´...<br><span style="font-size:14px; opacity:0.7">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>
    <video id="input_video" style="display:none"></video>
    <canvas id="output_canvas"></canvas>

<script>
/**
 * é…ç½®ä¸çŠ¶æ€ç®¡ç†
 */
const canvas = document.getElementById('output_canvas');
const ctx = canvas.getContext('2d');
const loading = document.getElementById('loading');

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// UI é…ç½®
const UI_CONFIG = {
    panelX: 40, panelY: 40, panelW: 280, panelH: 480, padding: 20,
    bgColor: 'rgba(30, 30, 40, 0.85)', // æ·±è‰²ç£¨ç ‚èƒŒæ™¯
    textColor: '#ffffff',
    accentColor: '#00ffff', // é€‰ä¸­é«˜äº®è‰²
    buttonRadius: 12,
    panelRadius: 20
};

// ç³»ç»ŸçŠ¶æ€
const state = {
    isMenuOpen: true, // é»˜è®¤æ‰“å¼€èœå•æ–¹ä¾¿æŸ¥çœ‹æ•ˆæœ
    mode: 'draw', 
    color: '#00FF00',
    lineWidth: 8, // é»˜è®¤ç¨å¾®ç²—ä¸€ç‚¹
    menuCooldown: 0,
    canvasScale: 1,
    canvasOffset: { x: 0, y: 0 },
    prevTwoFingerDist: null
};

let strokes = [];
let currentStroke = null;
let particles = [];

// UI æŒ‰é’®å®šä¹‰ (é‡æ–°å¸ƒå±€)
const buttons = [
    // å·¥å…·æ 
    { id: 'pen', label: 'âœï¸ ç”»ç¬”', x: 0, y: 60, w: 110, h: 70, type: 'mode', value: 'draw', color: '#4a4a5a' },
    { id: 'eraser', label: 'ğŸ§¼ æ©¡çš®', x: 130, y: 60, w: 110, h: 70, type: 'mode', value: 'erase', color: '#4a4a5a' },
    // é¢œè‰²æ 
    { id: 'red', label: '', x: 0, y: 160, w: 70, h: 70, type: 'color', value: '#FF3B30', color: '#FF3B30' },
    { id: 'green', label: '', x: 85, y: 160, w: 70, h: 70, type: 'color', value: '#34C759', color: '#34C759' },
    { id: 'blue', label: '', x: 170, y: 160, w: 70, h: 70, type: 'color', value: '#007AFF', color: '#007AFF' },
    // æ›´å¤šé¢œè‰²
    { id: 'yellow', label: '', x: 0, y: 250, w: 70, h: 70, type: 'color', value: '#FFCC00', color: '#FFCC00' },
    { id: 'purple', label: '', x: 85, y: 250, w: 70, h: 70, type: 'color', value: '#AF52DE', color: '#AF52DE' },
    { id: 'white', label: '', x: 170, y: 250, w: 70, h: 70, type: 'color', value: '#FFFFFF', color: '#FFFFFF' },

    // å°ºå¯¸æ 
    { id: 'size-', label: 'A å°', x: 0, y: 350, w: 110, h: 70, type: 'action', action: () => state.lineWidth = Math.max(2, state.lineWidth - 3), color: '#5a5a6a' },
    { id: 'size+', label: 'A å¤§', x: 130, y: 350, w: 110, h: 70, type: 'action', action: () => state.lineWidth = Math.min(40, state.lineWidth + 3), color: '#5a5a6a' },
];

// é¢„è®¡ç®—æŒ‰é’®ç»å¯¹åæ ‡
buttons.forEach(btn => {
    btn.absX = UI_CONFIG.panelX + UI_CONFIG.padding + btn.x;
    btn.absY = UI_CONFIG.panelY + UI_CONFIG.padding + btn.y;
});


/**
 * æ ¸å¿ƒé€»è¾‘å¾ªç¯
 */
function onResults(results) {
    loading.style.display = 'none';
    ctx.save();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
    
    drawStrokes();
    updateAndDrawParticles();

    if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const hand1 = results.multiHandLandmarks[0];
        const hand2 = results.multiHandLandmarks.length > 1 ? results.multiHandLandmarks[1] : null;

        // åŒæ‰‹ç¼©æ”¾
        if (hand1 && hand2) detectZoom(hand1, hand2);
        else state.prevTwoFingerDist = null;

        // å•æ‰‹é€»è¾‘
        const lm = hand1;
        const indexTip = { x: lm[8].x * canvas.width, y: lm[8].y * canvas.height };
        const thumbTip = { x: lm[4].x * canvas.width, y: lm[4].y * canvas.height };
        const middleTip = { x: lm[12].x * canvas.width, y: lm[12].y * canvas.height };
        
        const pinchDist = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
        const peaceDist = Math.hypot(indexTip.x - middleTip.x, indexTip.y - middleTip.y);
        
        // æ‰‹æŒæ£€æµ‹ (ç®€åŒ–ç‰ˆï¼šæ£€æµ‹å°æŒ‡æ ¹éƒ¨åˆ°é£ŸæŒ‡å°–è·ç¦»)
        const palmSize = Math.hypot(lm[8].x - lm[17].x, lm[8].y - lm[17].y);
        const isPalmOpen = palmSize > 0.25 && pinchDist > 80 && peaceDist > 80;

        if (state.menuCooldown > 0) state.menuCooldown--;

        // åˆ‡æ¢èœå•
        if (isPalmOpen && state.menuCooldown === 0) {
            state.isMenuOpen = !state.isMenuOpen;
            state.menuCooldown = 20;
            currentStroke = null;
        }

        if (state.isMenuOpen) {
            drawMenu(indexTip);
            drawCursor(indexTip, 'pointer');
        } else {
            // å‰ªåˆ€æ‰‹æ¶ˆæ•£
            if (peaceDist > 70 && !currentStroke && palmSize > 0.15) {
                 if (strokes.length > 0) explodeStrokesToParticles();
                 drawCursor(indexTip, 'magic');
            }
            // æåˆå†™å­—
            else if (pinchDist < 40) {
                const drawX = (indexTip.x - state.canvasOffset.x) / state.canvasScale;
                const drawY = (indexTip.y - state.canvasOffset.y) / state.canvasScale;

                if (!currentStroke) {
                    currentStroke = { 
                        points: [{x: drawX, y: drawY}], 
                        color: state.color,
                        isEraser: state.mode === 'erase',
                        size: state.lineWidth 
                    };
                    strokes.push(currentStroke);
                } else {
                    currentStroke.points.push({x: drawX, y: drawY});
                }
                // ç¬”å°–åé¦ˆåœˆ
                ctx.beginPath();
                ctx.arc(indexTip.x, indexTip.y, state.lineWidth/2 * state.canvasScale, 0, 2 * Math.PI);
                ctx.fillStyle = state.mode === 'erase' ? 'rgba(255,255,255,0.5)' : state.color;
                ctx.fill();
            } else {
                currentStroke = null;
                drawCursor(indexTip, 'hover');
            }
        }
    }
    ctx.restore();
}

/**
 * è¾…åŠ©ç»˜å›¾å‡½æ•°
 */

// ç»˜åˆ¶åœ†è§’çŸ©å½¢
function roundRect(x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
}

// å…³é”®ä¿®å¤ï¼šç»˜åˆ¶æœªé•œåƒçš„æ–‡æœ¬
function drawUnmirroredText(text, x, y, fontSize = 16, color = UI_CONFIG.textColor, align = 'center') {
    ctx.save();
    // 1. ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®
    ctx.translate(x, y);
    // 2. æ°´å¹³å†æ¬¡ç¿»è½¬ï¼ˆè´Ÿè´Ÿå¾—æ­£ï¼‰
    ctx.scale(-1, 1);
    // 3. ç»˜åˆ¶æ–‡æœ¬ (æ­¤æ—¶åæ ‡ç³»åŸç‚¹åœ¨x,yï¼Œä¸”æ–¹å‘æ­£ç¡®)
    ctx.fillStyle = color;
    ctx.font = `bold ${fontSize}px -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif`;
    ctx.textAlign = align;
    ctx.textBaseline = 'middle';
    ctx.fillText(text, 0, 0); 
    ctx.restore();
}

// ç»˜åˆ¶ç¾åŒ–åçš„UIé¢æ¿
function drawMenu(pointerPos) {
    // 1. ç»˜åˆ¶é¢æ¿èƒŒæ™¯ (å¸¦é˜´å½±å’Œåœ†è§’)
    ctx.shadowColor = 'rgba(0,0,0,0.5)';
    ctx.shadowBlur = 20;
    ctx.fillStyle = UI_CONFIG.bgColor;
    roundRect(UI_CONFIG.panelX, UI_CONFIG.panelY, UI_CONFIG.panelW, UI_CONFIG.panelH, UI_CONFIG.panelRadius, true, false);
    ctx.shadowBlur = 0; // é‡ç½®é˜´å½±

    // 2. ç»˜åˆ¶æ ‡é¢˜æ æ–‡å­— (ä½¿ç”¨ä¿®å¤å‡½æ•°)
    drawUnmirroredText("æ§åˆ¶é¢æ¿", UI_CONFIG.panelX + UI_CONFIG.panelW / 2, UI_CONFIG.panelY + 25, 18);
    drawUnmirroredText(`å½“å‰ç²—ç»†: ${state.lineWidth}`, UI_CONFIG.panelX + UI_CONFIG.panelW / 2, UI_CONFIG.panelY + UI_CONFIG.panelH - 25, 14, '#aaa');

    // 3. ç»˜åˆ¶æŒ‰é’®
    for (let btn of buttons) {
        let isHover = pointerPos.x > btn.absX && pointerPos.x < btn.absX + btn.w &&
                      pointerPos.y > btn.absY && pointerPos.y < btn.absY + btn.h;
        
        // åˆ¤æ–­æ˜¯å¦é€‰ä¸­
        let isActive = (btn.type === 'mode' && state.mode === btn.value) ||
                       (btn.type === 'color' && state.color === btn.value && state.mode === 'draw');

        // æŒ‰é’®èƒŒæ™¯è‰²
        ctx.fillStyle = isActive ? btn.value : btn.color;
        // å¦‚æœæ˜¯é¢œè‰²æŒ‰é’®ä¸”é€‰ä¸­ï¼Œå¢åŠ å‘å…‰æ•ˆæœ
        if (isActive && btn.type === 'color') {
             ctx.shadowColor = btn.value;
             ctx.shadowBlur = 15;
        }

        // ç»˜åˆ¶æŒ‰é’®ä¸»ä½“
        roundRect(btn.absX, btn.absY, btn.w, btn.h, UI_CONFIG.buttonRadius, true, isHover || isActive);
        ctx.shadowBlur = 0;

        // æ‚¬åœè¾¹æ¡†
        if (isHover) {
            ctx.strokeStyle = UI_CONFIG.accentColor;
            ctx.lineWidth = 3;
            roundRect(btn.absX, btn.absY, btn.w, btn.h, UI_CONFIG.buttonRadius, false, true);
            btn.type === 'action' && btn.action(); // è§¦å‘åŠ¨ä½œ
        }
        
        // é€‰ä¸­è¾¹æ¡†
        if (isActive && btn.type !== 'color') {
            ctx.strokeStyle = UI_CONFIG.accentColor;
            ctx.lineWidth = 3;
             roundRect(btn.absX, btn.absY, btn.w, btn.h, UI_CONFIG.buttonRadius, false, true);
        }

        // 4. ç»˜åˆ¶æŒ‰é’®æ–‡å­—/å›¾æ ‡ (ä½¿ç”¨ä¿®å¤å‡½æ•°)
        if (btn.label) {
            // é¢œè‰²æŒ‰é’®ä¸æ˜¾ç¤ºæ–‡å­—ï¼Œå…¶ä»–æ˜¾ç¤º
            const textColor = (btn.type === 'color' || isActive) ? '#fff' : UI_CONFIG.textColor;
            drawUnmirroredText(btn.label, btn.absX + btn.w / 2, btn.absY + btn.h / 2, 16, textColor);
        }
        
        // ç‚¹å‡»é€»è¾‘å¤„ç† (ç®€å•è§¦å‘)
        if (isHover) {
             if (btn.type === 'mode') state.mode = btn.value;
             if (btn.type === 'color') { state.color = btn.value; state.mode = 'draw'; }
        }
    }
}

// ... (å…¶ä½™ drawStrokes, drawCursor, detectZoom, ç²’å­ç³»ç»Ÿ ä»£ç ä¸ä¹‹å‰ç›¸åŒï¼Œä¸ºèŠ‚çœç¯‡å¹…çœç•¥ï¼Œè¯·ç¡®ä¿ä¿ç•™åŸæœ‰çš„è¿™äº›å‡½æ•°)
// --- è¡¥å…¨ç¼ºå¤±çš„å‡½æ•°ä»¥ä¿è¯è¿è¡Œ ---
function drawCursor(pos, type) {
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, 10, 0, 2 * Math.PI);
    ctx.fillStyle = type === 'pointer' ? UI_CONFIG.accentColor : (type === 'magic' ? '#FFD700' : 'rgba(255,255,255,0.5)');
    ctx.fill();
    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
}

function drawStrokes() {
    ctx.save();
    ctx.translate(state.canvasOffset.x, state.canvasOffset.y);
    ctx.scale(state.canvasScale, state.canvasScale);
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    for (let stroke of strokes) {
        if (stroke.points.length < 2) continue;
        ctx.beginPath();
        ctx.moveTo(stroke.points[0].x, stroke.points[0].y);
        for (let i = 1; i < stroke.points.length; i++) ctx.lineTo(stroke.points[i].x, stroke.points[i].y);
        if (stroke.isEraser) { ctx.globalCompositeOperation = 'destination-out'; ctx.lineWidth = stroke.size * 2; }
        else { ctx.globalCompositeOperation = 'source-over'; ctx.strokeStyle = stroke.color; ctx.lineWidth = stroke.size; }
        ctx.stroke();
    }
    ctx.restore();
}

function detectZoom(hand1, hand2) {
    const p1 = { x: hand1[8].x * canvas.width, y: hand1[8].y * canvas.height };
    const p2 = { x: hand2[8].x * canvas.width, y: hand2[8].y * canvas.height };
    const dist = Math.hypot(p1.x - p2.x, p1.y - p2.y);
    if (state.prevTwoFingerDist) {
        const delta = dist - state.prevTwoFingerDist;
        if (Math.abs(delta) > 3) {
            state.canvasScale = Math.max(0.5, Math.min(3.0, state.canvasScale * (1 + delta * 0.003)));
        }
    }
    state.prevTwoFingerDist = dist;
}

function explodeStrokesToParticles() {
    for (let stroke of strokes) {
        if (stroke.isEraser) continue;
        for (let i = 0; i < stroke.points.length; i += 3) {
            particles.push({
                x: stroke.points[i].x * state.canvasScale + state.canvasOffset.x,
                y: stroke.points[i].y * state.canvasScale + state.canvasOffset.y,
                vx: (Math.random() - 0.5) * 5, vy: Math.random() * 3 + 2,
                life: 1.0, color: stroke.color, size: stroke.size * Math.random()
            });
        }
    }
    strokes = [];
}

function updateAndDrawParticles() {
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.02; p.vx += (Math.random()-0.5)*0.5;
        if (p.life <= 0) particles.splice(i, 1);
        else { ctx.beginPath(); ctx.arc(p.x, p.y, p.size/2, 0, Math.PI*2); ctx.fillStyle=p.color; ctx.globalAlpha=p.life; ctx.fill(); ctx.globalAlpha=1.0;}
    }
}
// --- è¡¥å…¨ç»“æŸ ---


/**
 * åˆå§‹åŒ– MediaPipe
 */
const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
hands.onResults(onResults);

const camera = new Camera(document.getElementById('input_video'), {
    onFrame: async () => await hands.send({image: document.getElementById('input_video')}),
    width: 1280, height: 720
});
camera.start();

</script>
</body>
</html>
