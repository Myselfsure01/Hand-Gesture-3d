<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Three.js æ‰‹åŠ¿æ§åˆ¶ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; color: white; font-family: sans-serif;}
        #info { position: absolute; top: 10px; left: 10px; z-index: 10; pointer-events: none; }
        video { display: none; } /* éšè—åŸå§‹æ‘„åƒå¤´ç”»é¢ */
        #preview { position: absolute; bottom: 10px; right: 10px; width: 200px; height: 150px; transform: scaleX(-1); border: 1px solid #333; z-index: 5;}
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="info">
        <h2>ğŸ‘‹ æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ</h2>
        <p>åŠ è½½ä¸­... è¯·å…è®¸æ‘„åƒå¤´æƒé™</p>
        <ul>
            <li>âœŒï¸ æ‰‹åŠ¿ 1/2/3: åˆ‡æ¢æ–‡å­—</li>
            <li>ğŸ¤ å¼ å¼€/æåˆ: æ§åˆ¶ç²’å­æ‰©æ•£</li>
        </ul>
        <p id="status">çŠ¶æ€: ç­‰å¾…æ‰‹åŠ¿...</p>
    </div>
    
    <canvas id="preview"></canvas>
    <video id="input_video"></video>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 100;

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // --- 2. ç²’å­ç³»ç»Ÿæ ¸å¿ƒé€»è¾‘ ---
        
        const PARTICLE_COUNT = 15000; // ç²’å­æ€»æ•°
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const colors = new Float32Array(PARTICLE_COUNT * 3);
        
        // å­˜å‚¨ç›®æ ‡ä½ç½®ï¼ˆæ–‡å­—å½¢çŠ¶ï¼‰
        let targetPositions = new Float32Array(PARTICLE_COUNT * 3);
        // å­˜å‚¨éšæœºä½ç½®ï¼ˆæ— æ‰‹åŠ¿æ—¶çš„çŠ¶æ€ï¼‰
        const randomPositions = new Float32Array(PARTICLE_COUNT * 3);

        const colorObj = new THREE.Color();

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            // åˆå§‹åŒ–éšæœºä½ç½®
            const x = (Math.random() - 0.5) * 200;
            const y = (Math.random() - 0.5) * 200;
            const z = (Math.random() - 0.5) * 200;

            positions[i * 3] = x;
            positions[i * 3 + 1] = y;
            positions[i * 3 + 2] = z;

            randomPositions[i * 3] = x;
            randomPositions[i * 3 + 1] = y;
            randomPositions[i * 3 + 2] = z;

            // åˆå§‹åŒ–é¢œè‰²
            colorObj.setHSL(Math.random(), 0.7, 0.5);
            colors[i * 3] = colorObj.r;
            colors[i * 3 + 1] = colorObj.g;
            colors[i * 3 + 2] = colorObj.b;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

        // æè´¨
        const material = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. æ–‡æœ¬ç”Ÿæˆé€»è¾‘ (Canvas é‡‡æ ·) ---
        
        function createTextCoordinates(text) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const width = 400;
            const height = 200;
            canvas.width = width;
            canvas.height = height;

            // ç»˜åˆ¶èƒŒæ™¯å’Œæ–‡å­—
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, width, height);
            
            // åŠ¨æ€è°ƒæ•´å­—ä½“å¤§å°
            let fontSize = 80;
            if (text.length > 8) fontSize = 50; 
            ctx.font = `Bold ${fontSize}px Arial`;
            ctx.fillStyle = '#FFFFFF';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, width / 2, height / 2);

            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const coords = [];

            // æ‰«æåƒç´ 
            for (let y = 0; y < height; y += 2) { // æ­¥é•¿2ï¼Œå‡å°‘é‡‡æ ·ç‚¹
                for (let x = 0; x < width; x += 2) {
                    const index = (y * width + x) * 4;
                    // å¦‚æœåƒç´ è¶³å¤Ÿäº®ï¼Œè§†ä¸ºç²’å­ç‚¹
                    if (data[index] > 128) {
                        coords.push({
                            x: (x - width / 2) * 0.8, // ç¼©æ”¾å› å­
                            y: -(y - height / 2) * 0.8, // ç¿»è½¬Yè½´
                            z: 0
                        });
                    }
                }
            }
            return coords;
        }

        // é¢„ç”Ÿæˆä¸‰ç§çŠ¶æ€çš„åæ ‡
        const coordsWorld = createTextCoordinates("World");
        const coordsHello = createTextCoordinates("Hello");
        const coordsHW = createTextCoordinates("Hello World");

        // æ›´æ–°ç›®æ ‡ä½ç½®çš„å‡½æ•°
        function setTarget(shapeType) {
            let sourceCoords = [];
            if (shapeType === 1) sourceCoords = coordsWorld;
            else if (shapeType === 2) sourceCoords = coordsHello;
            else if (shapeType === 3) sourceCoords = coordsHW;
            else sourceCoords = []; // éšæœºæ¨¡å¼

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                if (i < sourceCoords.length) {
                    // ç»„æˆæ–‡å­—
                    targetPositions[i * 3] = sourceCoords[i].x;
                    targetPositions[i * 3 + 1] = sourceCoords[i].y;
                    targetPositions[i * 3 + 2] = sourceCoords[i].z;
                } else {
                    // å¤šä½™çš„ç²’å­å›åˆ°éšæœºä½ç½®ï¼ˆæˆ–è€…é£æ•£ï¼‰
                    targetPositions[i * 3] = (Math.random() - 0.5) * 200;
                    targetPositions[i * 3 + 1] = (Math.random() - 0.5) * 200;
                    targetPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                }
            }
        }
        
        // åˆå§‹è®¾ä¸ºéšæœº
        setTarget(0);

        // --- 4. MediaPipe æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---

        const videoElement = document.getElementById('input_video');
        const previewCanvas = document.getElementById('preview');
        const previewCtx = previewCanvas.getContext('2d');
        const statusEl = document.getElementById('status');

        let expansionFactor = 1.0; // æ‰©æ•£/æ”¶ç¼©ç³»æ•°
        let currentGesture = 0;

        function onResults(results) {
            // ç»˜åˆ¶é¢„è§ˆå›¾
            previewCtx.save();
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            previewCtx.drawImage(results.image, 0, 0, previewCanvas.width, previewCanvas.height);
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                
                // 1. ç®€å•çš„æ‰‹åŠ¿ç»˜åˆ¶
                drawConnectors(previewCtx, landmarks, HAND_CONNECTIONS, {color: '#00FF00', lineWidth: 2});

                // 2. æ£€æµ‹æ‰‹æŒ‡æ•°é‡ (åˆ¤æ–­ 1, 2, 3)
                // æŒ‡å°–ç´¢å¼•: é£ŸæŒ‡(8), ä¸­æŒ‡(12), æ— åæŒ‡(16), å°æŒ‡(20)
                // ç®€å•çš„åˆ¤å®šï¼šæŒ‡å°–Yåæ ‡ < æŒ‡å…³èŠ‚Yåæ ‡ (æ³¨æ„Canvasåæ ‡ç³»Yå‘ä¸‹)
                let fingersUp = 0;
                if (landmarks[8].y < landmarks[6].y) fingersUp++; // é£ŸæŒ‡
                if (landmarks[12].y < landmarks[10].y) fingersUp++; // ä¸­æŒ‡
                if (landmarks[16].y < landmarks[14].y) fingersUp++; // æ— åæŒ‡
                if (landmarks[20].y < landmarks[18].y) fingersUp++; // å°æŒ‡
                // æ‹‡æŒ‡åˆ¤æ–­ (Xè½´å·®å¼‚)
                if (Math.abs(landmarks[4].x - landmarks[17].x) > Math.abs(landmarks[3].x - landmarks[17].x)) fingersUp++;

                // æ›´æ–°æ–‡å­—çŠ¶æ€
                let newGesture = 0;
                // ä¸ºäº†å®¹é”™ï¼Œæ˜ å°„å¸¸è§çš„æ‰‹æŒ‡æ•°é‡
                if (fingersUp === 1) newGesture = 1;
                else if (fingersUp === 2) newGesture = 2;
                else if (fingersUp >= 3) newGesture = 3; // 3æŒ‡åŠä»¥ä¸Šç®—Hello World
                else newGesture = 0; // æ‹³å¤´æˆ–æ— æ‰‹åŠ¿

                if (newGesture !== currentGesture) {
                    currentGesture = newGesture;
                    setTarget(currentGesture);
                    
                    let text = "éšæœºæ¼«æ¸¸";
                    if (currentGesture === 1) text = "World";
                    if (currentGesture === 2) text = "Hello";
                    if (currentGesture === 3) text = "Hello World";
                    statusEl.innerText = `æ£€æµ‹åˆ°æ‰‹åŠ¿: ${fingersUp} æŒ‡ -> ${text}`;
                }

                // 3. æ£€æµ‹æ‰‹æŒå¼ åˆç¨‹åº¦ (æ§åˆ¶æ‰©æ•£)
                // è®¡ç®—æ‹‡æŒ‡å°–(4)å’Œé£ŸæŒ‡å°–(8)çš„è·ç¦»ï¼Œæˆ–è€…æ‰‹æŒçš„è¾¹ç•Œæ¡†å¤§å°
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const distance = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                
                // å½’ä¸€åŒ–å¤„ç†ï¼šè·ç¦»ä¸€èˆ¬åœ¨ 0.05 (æåˆ) åˆ° 0.25 (å¼ å¼€) ä¹‹é—´
                // æˆ‘ä»¬å°†å…¶æ˜ å°„åˆ° expansionFactor
                // ç›®æ ‡ï¼šå¼ å¼€ -> 1.0 (æ­£å¸¸), æåˆ -> 0.1 (æ”¶ç¼©/çˆ†ç‚¸), æˆ–è€…åè¿‡æ¥
                // ç”¨æˆ·éœ€æ±‚ï¼šåŒæ‰‹å¼ åˆæ§åˆ¶æ”¶ç¼©ä¸æ‰©æ•£ã€‚æˆ‘ä»¬å®šä¹‰ï¼šå¼ å¼€=æ‰©æ•£(ç²’å­æ•£å¼€)ï¼Œæåˆ=æ”¶ç¼©(ç²’å­èšæ‹¢)
                
                // å¹³æ»‘è¿‡æ¸¡
                const targetFactor = THREE.MathUtils.mapLinear(distance, 0.05, 0.3, 0.5, 3.0);
                expansionFactor += (targetFactor - expansionFactor) * 0.1;

            } else {
                // æ— æ‰‹åŠ¿æ—¶ï¼Œç¼“æ…¢æ¢å¤é»˜è®¤
                expansionFactor += (1.0 - expansionFactor) * 0.05;
                statusEl.innerText = "æœªæ£€æµ‹åˆ°æ‰‹éƒ¨";
            }
            previewCtx.restore();
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});
        
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        
        hands.onResults(onResults);

        // å¯åŠ¨æ‘„åƒå¤´
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();


        // --- 5. åŠ¨ç”»å¾ªç¯ ---
        
        function animate() {
            requestAnimationFrame(animate);

            const time = Date.now() * 0.001;
            const positionsArray = geometry.attributes.position.array;

            // ç²’å­è¿åŠ¨é€»è¾‘
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const px = i * 3;
                const py = i * 3 + 1;
                const pz = i * 3 + 2;

                // è·å–å½“å‰ä½ç½®
                let cx = positionsArray[px];
                let cy = positionsArray[py];
                let cz = positionsArray[pz];

                // è·å–ç›®æ ‡ä½ç½® (æ¥è‡ªæ–‡å­—æˆ–éšæœº)
                const tx = targetPositions[px];
                const ty = targetPositions[py];
                const tz = targetPositions[pz];

                // 1. åŸºç¡€è¿åŠ¨ï¼šå‘ç›®æ ‡ä½ç½®æ’å€¼ (Lerp)
                // é€Ÿåº¦ç³»æ•°
                const speed = 0.08; 
                cx += (tx - cx) * speed;
                cy += (ty - cy) * speed;
                cz += (tz - cz) * speed;

                // 2. å™ªç‚¹æ‰°åŠ¨ (è®©ç²’å­åƒåœ¨å‘¼å¸)
                const noise = 0.5;
                cx += Math.sin(time + cy * 0.1) * noise * (expansionFactor * 0.5);
                cy += Math.cos(time + cx * 0.1) * noise * (expansionFactor * 0.5);

                // 3. åº”ç”¨æ‰‹åŠ¿æ‰©æ•£/æ”¶ç¼©
                // å¦‚æœ expansionFactor å¾ˆå¤§ï¼Œç²’å­ç›¸äº’è¿œç¦»ä¸­å¿ƒï¼›å¦‚æœå¾ˆå°ï¼Œèšæ‹¢
                // è¿™é‡Œæˆ‘ä»¬ç®€å•åœ°åˆ©ç”¨ä½ç½®*ç³»æ•°æ¥å®ç°æ•´ä½“ç¼©æ”¾æ•ˆæœï¼Œ
                // æˆ–è€…æ›´é«˜çº§åœ°ï¼šåŸºäºç›®æ ‡ä½ç½®è¿›è¡Œç¼©æ”¾
                
                // æœ€ç»ˆä½ç½®å†™å…¥
                // expansionFactor = 1.0 æ˜¯æ ‡å‡†æ–‡å­—å¤§å°
                // å¤§äº 1.0 æ–‡å­—å˜å¤§/æ•£å¼€
                positionsArray[px] = cx * (0.9 + expansionFactor * 0.1); 
                positionsArray[py] = cy * (0.9 + expansionFactor * 0.1);
                positionsArray[pz] = cz * (0.9 + expansionFactor * 0.1);
            }

            geometry.attributes.position.needsUpdate = true;
            
            // ç¼“æ…¢æ—‹è½¬åœºæ™¯
            scene.rotation.y += 0.002;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // çª—å£è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
